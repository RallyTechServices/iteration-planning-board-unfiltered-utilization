<!DOCTYPE html>
<html>
<head>
    <title>Iteration Planning Board (Unfiltered Utilization)</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Nov 19 2015 13:41:00 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Nov 19 2015 13:41:00 GMT-0700 (MST)";
        var CHECKSUM = 213748717893;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define("iteration-planning-board-unfiltered-utilization", {
        extend: 'Rally.app.App',
        requires: [
            'Rally.ui.gridboard.planning.TimeboxGridBoard',
            'Rally.ui.gridboard.plugin.GridBoardAddNew',
            'Rally.ui.gridboard.plugin.GridBoardManageIterations',
            'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl'
        ],
        mixins: ['Rally.app.CardFieldSelectable'],
        modelNames: ['User Story', 'Defect'],

        config: {
            defaultSettings: {
                cardFields: 'Parent,Tasks,Defects,Discussion,PlanEstimate'
            }
        },

        launch: function() {
            var context = this.getContext(),
                plugins = [
                    {
                        ptype: 'rallygridboardaddnew',
                        rankScope: 'BACKLOG',
                        addNewControlConfig: {
                            stateful: true,
                            stateId: context.getScopedStateId('iteration-planning-add-new')
                        }
                    },
                    {
                        ptype: 'rallygridboardcustomfiltercontrol',
                        filterControlConfig: {
                            margin: '3 9 3 30',
                            blackListFields: ['Iteration', 'PortfolioItem'],
                            modelNames: this.modelNames,
                            stateful: true,
                            stateId: context.getScopedStateId('iteration-planning-custom-filter-button')
                        },
                        showOwnerFilter: true,
                        ownerFilterControlConfig: {
                            stateful: true,
                            stateId: context.getScopedStateId('iteration-planning-owner-filter')
                        }
                    }
                ];

            if (context.getSubscription().isHsEdition() || context.getSubscription().isExpressEdition()) {
                plugins.push('rallygridboardmanageiterations');
            }

            this.gridboard = this.add({
                xtype: 'rallytimeboxgridboard',
                context: context,
                modelNames: this.modelNames,
                timeboxType: 'Iteration',
                plugins: plugins,
                cardBoardConfig: {
                    cardConfig: {
                        fields:  this.getCardFieldNames()
                    },
                    columnConfig: {
                        additionalFetchFields: ['PortfolioItem']
                    },
                    listeners: {
                        filter: this._onBoardFilter,
                        filtercomplete: this._onBoardFilterComplete,
                        scope: this
                    }
                },
                listeners: {
                    load: this._onLoad,
                    toggle: this._publishContentUpdated,
                    recordupdate: this._publishContentUpdatedNoDashboardLayout,
                    recordcreate: this._publishContentUpdatedNoDashboardLayout,
                    preferencesaved: this._publishPreferenceSaved,
                    scope: this
                }
            });
        },

        getSettingsFields: function () {
            var fields = this.callParent(arguments);
            this.appendCardFieldPickerSetting(fields);
            return fields;
        },

        _onLoad: function() {
            this._publishContentUpdated();
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _onBoardFilter: function() {
            this.setLoading(true);
        },

        _onBoardFilterComplete: function() {
            this.setLoading(false);
        },

        _publishContentUpdated: function() {
            this.fireEvent('contentupdated');
        },

        _publishContentUpdatedNoDashboardLayout: function() {
            this.fireEvent('contentupdated', {dashboardLayout: false});
        },

        _publishPreferenceSaved: function(record) {
            this.fireEvent('preferencesaved', record);
        }
    });
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * The base column implementation.
     *
     * In general, this class will not be created directly but instead will be instantiated by Rally.ui.cardboard.CardBoard
     * as specified by its columnConfig:
     *
     *     columnConfig: {
     *         xtype: 'rallycardboardcolumn'
     *     }
     */
    Ext.define('Rally.ui.cardboard.Column', {
        extend: 'Ext.Component',
        alias: 'widget.rallycardboardcolumn',

        requires: [
            'Rally.util.Array',
            'Rally.util.Ui',
            'Rally.ui.cardboard.plugin.ColumnDropController',
            'Rally.ui.cardboard.Card',
            'Rally.ui.cardboard.ColumnHeader',
            'Rally.ui.cardboard.CardRecordProcessor',
            'Rally.util.Ref',
            'Rally.ui.cardboard.plugin.ColumnWIP',
            'Rally.util.SafeExting',
            'Rally.util.Test',
            'Rally.ui.cardboard.CardFieldFetch',
            'Rally.data.wsapi.Filter',
            'Rally.data.Ranker',
            'Deft.Promise'
        ],

        mixins: {
            messageable: 'Rally.Messageable',
            datastoreCreateable: 'Rally.data.DataStoreCreateable',
            filterable: 'Rally.data.filter.StoreFilterable', // DEPRECATED!  DO NOT CALL METHODS MIXED IN HERE.
            clientMetrics: 'Rally.clientmetrics.ClientMetricsRecordable'
        },

        inheritableStatics: {
            HIDDEN_CLS: 'rly-hidden'
        },

        /**
         * @property {String} cls The base class applied to this object's element
         */
        cls: 'column',

        clientMetrics: [
            {
                beginMethod: '_queryForData',
                endEvent: 'load',
                description: 'column loaded'
            },
            {
                beginMethod: 'loadMoreRecords',
                endMethod: '_onStoreLoad',
                description: 'autoload records'
            }
        ],

        /**
         * @property {Ext.Component} columnHeader The header for the column.
         */
        columnHeader: null,

        /**
         * @property {Rally.ui.cardboard.Cardboard}
         * The Cardboard the Column belongs to.
         */
        ownerCardboard: null,

        config: {
            /**
             * @cfg {Object} cardConfig
             * A config object that will be applied to the column's cards.  Any of the config options available for Rally.ui.cardboard.Card can be specified here.
             */
            cardConfig: {
                xtype: 'rallycard'
            },
            /**
             * @cfg {Object} columnHeaderConfig
             * A config object that will be applied to the column's header.  Any of the config options available for Rally.ui.cardboard.ColumnHeader can be specified here.
             */
            columnHeaderConfig: {
                xtype: 'rallycardboardcolumnheader'
            },

            /**
             * @cfg {Boolean} enableWipLimit If set to true will add the ColumnWip plugin to this column
             */
            enableWipLimit: false,

            /**
             *  @cfg {Number} wipLimit
             *  The maximum wip allowed in this column. A value of -1 is is equivalent to a wip of infinity.
             */
            wipLimit: -1,

            /**
             *  @cfg {Boolean/String/Number} value (required)
             *  The value that will be assigned to the card's record when it is dropped into this column.
             */
            value: undefined,

            /**
             *  @cfg {String} valueField
             *  The record field that will be the value that will be assigned to the card's record when it is dropped into this column.
             */
            valueField: undefined,

            /**
             *  @cfg {String} displayField
             *  The record field that that will be displayed in the header of the column
             *  This is only used by KanbanPolicy, not by PKPolicy
             */
            displayField: undefined,

            /**
             *  @cfg {Object} record
             *  The record for the column that is being added to the cardboard
             */
            record: undefined,

            /**
             * @cfg {Boolean} enableCrossColumnRanking If set to true will allow the cards to be reranked when dropped into a new column.
             */
            enableCrossColumnRanking: false,

            /**
             * @cfg {Boolean} enableRanking (required)
             * Set to true if the workspace is drag and drop enabled.
             */
            enableRanking: true,

            /**
             * @cfg {Boolean}
             * Set to false to disable drag and drop across rows.
             */
            enableCrossRowDragging: true,

            /**
             * @cfg {Boolean} dropControllerConfig
             * Plugin config object for a drop controller plugin. Set to true to use the default
             * {Rally.ui.cardboard.plugin.ColumnDropController} plugin, or set to false to disable
             * dropping in this column.
             */
            dropControllerConfig: true,

            /**
             * @cfg {Number}
             * The minimum number of cards that will be auto loaded off screen.
             * If this threshold is not met, then another page of cards will be automatically loaded.
             */
            autoLoadCardThreshold: 5,

            /**
             * @cfg {Number}
             * The amount of milliseconds to wait before calculating whether an auto load is required
             * whenever an event occurs, such as scrolling, that could trigger an auto load.
             */
            autoLoadPollingDelay: 100,

            /**
             * @cfg {Array}
             * An array of field names that each card will show for this column
             */
            fields: [],

            /**
             * @cfg {Array}
             * An array of names of additional fetch fields for displaying more fields on a card
             */
            additionalFetchFields: [],

            /**
             * @cfg {Rally.env.Context} context
             * Current application context object (user, workspace, project, scoping, etc.)
             */
            context: undefined,

            /**
             * Deprecated, use 'model' (singular) config instead.
             *
             * @cfg {Array}
             * @deprecated
             */
            models: [],

            /**
             * @cfg {Boolean}
             * @private
             * Flag to specify whether this column needs to generate different filters for different types.
             * Should be set to false if the filters returned from Rally.ui.cardboard.Column#getStoreFilter
             * are applicable to all types being displayed.
             */
            requiresModelSpecificFilters: true
        },

        /**
         * @constructor
         * @param {Object} config
         */
        constructor: function(config) {
            this.mergeConfig(config);

            if (Ext.isEmpty(this.model) && !Ext.isEmpty(this.models)) {
                // support deprecated this.models config option
                this.model = this.models;
            }

            this.plugins = this.plugins || [];
            this.initConfig(config);

            if (this.enableWipLimit) {
                this.plugins.push({
                    ptype: 'rallycolumnwipcontent',
                    wipLimit: this.wipLimit
                });
            }

            this.plugins.push('rallycardboardcardrecordprocessor');

            this._initDropController();

            this.callParent([this.config]);
        },

        initComponent: function() {
            this.addEvents(
                /**
                 * @event
                 * Fires when a card is picked up from this column.
                 * @param {Rally.ui.cardboard.Card} card The picked up card.
                 */
                'cardpickedup',
                /**
                 * @event
                 * Fires before a card that has been dropped has updated its data to Rally.
                 * @param {Rally.ui.cardboard.Column} this
                 * @param {Rally.ui.cardboard.Card} card The card that will be dropped
                 * @param {String} type The type of drop that was done.  Either 'reorder' or 'move'.
                 * @param {Rally.ui.cardboard.Column} sourceColumn The column that the card was dragged from
                 */
                'beforecarddroppedsave',

                /**
                 * @event
                 * Fires after a card that has been dropped has updated its data to Rally.
                 * @param {Rally.ui.cardboard.Column} this
                 * @param {Rally.ui.cardboard.Card} card The card that will be dropped
                 * @param {String} type The type of drop that was done.  Either 'reorder' or 'move'.
                 * @param {Rally.ui.cardboard.Column} sourceColumn The column that the card was dragged from
                 */
                'aftercarddroppedsave',

                /**
                 * @event
                 * Fires once the data is loaded
                 * @param {Rally.ui.cardboard.CardBoard} this
                 * @param {Rally.data.Model[]} records Records that will be used as backing objects for the cards
                 */
                'load',
                /**
                 * @event
                 * Fires when all the cards have been displayed
                 * @param {Rally.ui.cardboard.Column} this
                 */
                'ready',
                /**
                 * @event
                 * Fires when a column is filtered
                 * @param {Rally.ui.cardboard.Column} column The column that was filtered
                 */
                'filter',
                /**
                 * @event
                 * Fires when a card's record has been updated such that it no longer belongs in this column
                 * @param {Rally.ui.cardboard.Card} card The card which no longer belongs in this column
                 * @param {Rally.ui.cardboard.Column} column This column
                 */
                'cardinvalid',
                /**
                 * @event
                 * Fires when a card is added, refreshed or removed from this column
                 */
                'cardupdated',
                /**
                 * @event
                 * Fires when a card is ready
                 * @param {Rally.ui.cardboard.Card} the card that is now ready
                 */
                'cardready',
                /**
                 * @event
                 * Fires before a card is rendered
                 * @param {Rally.ui.cardboard.Card} card The card that is about to be rendered to this column
                 * @param {Rally.ui.cardboard.Column} column This column
                 */
                'beforecardrender'
            );
            this.callParent(arguments);

            this._cardsByRow = {};

            this._setLoading(true);
            this._queryForData();

            this.on('afterrender', this._addScrollListener, this);

            this.on('hide', function () {
                this.on('show', this.autoLoadCards, this, { single: true });
            }, this);
        },

        /**
         * Refreshes the column with the newConfig parameters
         * @param {Object} newConfig
         */
        refresh: function(newConfig) {
            this.clearCards();
            this.store = null;

            Rally.util.SafeExting.mergeOwnProperties(this, newConfig);

            this._queryForData();
        },

        /**
         * Load the Column's store after configuring store with filters and page size
         */
        loadStore: function() {
            this._setLoading(true);
            this._initStoreFilters();
            delete this._hasStoppedLoadingRecords;
            this.store.load();
        },

        getStore: function() {
            return this.store;
        },

        /**
         * Returns whether cards may be reranked when dragged within this column.
         * @return {Boolean} If reranking is allowed
         */
        mayRank: function() {
            var sorter = this.store.sorters.last();
            return Rally.data.Ranker.isRankField(sorter.property) &&
                sorter.direction === 'ASC' &&
                this.enableRanking;
        },

        _initDropController: function() {
            var dropControllerConfig = this.dropControllerConfig;
            if (dropControllerConfig) {
                var defaultConfig = {ptype: 'rallycolumndropcontroller'},
                    pluginConfig = Ext.isObject(dropControllerConfig) ? dropControllerConfig : defaultConfig;

                this.plugins = this.plugins || [];
                this.plugins.push(pluginConfig);
            }
        },

        _addScrollListener: function () {
            // DE20765: To disable browser auto scrolling to previous location on page load in Firefox,
            // set scrollTop to 0 on initial scroll
            if (Ext.isGecko) {
                this.on('scroll', function (event, element) {
                    this._scrollToTop(element);
                }, this, { single: true });
            }

            this.on('scroll', function () { this.autoLoadCards(); }, this);

            var scrollElement = this.getScrollElement();
            if (scrollElement) {
                this.mon(Ext.fly(scrollElement), 'scroll', this._onScroll, this);
            }

            this.mon(Ext.fly(window), 'scroll', this._onScroll, this);
        },

        _onScroll: function (event, element) {
            this.fireEvent('scroll', this, element);
        },

        _scrollToTop: function (domElement) {
            var scrollElement = this.getScrollElement();
            var scrollDom = scrollElement && scrollElement.dom;

            // DE20765: If the scroll event was not fired by the scroll element,
            // then scroll the window instead. Without this, Firefox will still remember the old window scroll location,
            // causing constant auto loads until the position is reached
            if (!scrollDom || scrollDom !== domElement) {
                scrollElement = window;
            }

            scrollElement.scrollTo('top', 0);
        },

        autoLoadCards: function () {
            if (this._waitForAutoLoad) {
                this._queueAutoLoad = true;
                return;
            }

            if (!this.isLoading() && this._shouldAutoLoadMoreRecords()) {
                this.loadMoreRecords();
            }

            this._waitForAutoLoad = true;

            Ext.defer(function () {
                delete this._waitForAutoLoad;

                if (this._queueAutoLoad) {
                    delete this._queueAutoLoad;
                    this.autoLoadCards();
                }
            }, this.autoLoadPollingDelay, this);
        },

        /**
         * Returns all the fields that are needed to be fetched by the CardBoard
         * @returns {String[]} The fetch fields.
         */
        getAllFetchFields: function() {
            var requiredFetchFields = [this.attribute, 'ObjectID', 'Workspace'],
                cardClass = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias('widget.' + this.cardConfig.xtype));

            if (this.isCardAgeEnabled()) {
                requiredFetchFields.push('VersionId');
                requiredFetchFields.push('RevisionHistory');
                requiredFetchFields.push('CreationDate');
            }

            var sorters = (this.store && this.store.sorters.getRange()) || (this.storeConfig && this.storeConfig.sorters) || [];
            if(Ext.isEmpty(sorters)) {
                sorters.push(this._getDefaultSorter());
            }

            var allFields = _.compact(_.union(
                requiredFetchFields,
                this.additionalFetchFields,
                cardClass.getFetchFields(),
                this.fields,
                this.storeConfig.fetch || [],
                _.pluck(sorters, 'property')
            ));

            return Rally.ui.cardboard.CardFieldFetch.getFetchFields(allFields, this.storeConfig.useShallowFetch);
        },

        isCardAgeEnabled: function() {
            return this.cardConfig.showAge > -1;
        },

        show: function() {
            if(this.getColumnHeaderCell()) {
                this.getColumnHeaderCell().removeCls(this.self.HIDDEN_CLS);
            }
            _.invoke(this.getContentCellContainers(), 'removeCls', this.self.HIDDEN_CLS);
            this.callParent(arguments);
        },

        hide: function() {
            this.callParent(arguments);
            if(this.getColumnHeaderCell()) {
                this.getColumnHeaderCell().addCls(this.self.HIDDEN_CLS);
            }
            _.invoke(this.getContentCellContainers(), 'addCls', this.self.HIDDEN_CLS);
        },

        /**
         * Returns a filter config to be applied to the column's store.
         *
         * This function will be called for each model being displayed during column initialization.
         *
         * @template
         * @param {Rally.data.wsapi.Model} model The model the filter will be applied.
         * @return {Object|Object[]} the filter config to be applied
         */
        getStoreFilter: function(model) {
            return {
                property: this.attribute,
                operator: '=',
                value: this.getValue()
            };
        },

        _getModelScopedFilters: function(models) {
            if(!this.requiresModelSpecificFilters) {
                return [this.getStoreFilter()];
            } else {
                var filters = _.map(models, function (model) {
                    // filter by typeDefOid so we only get back the models we asked for
                    var filter = Ext.create('Rally.data.wsapi.Filter', {
                        property: 'TypeDefOid',
                        value: model.typeDefOid,
                        operator: '='
                    });

                    // AND all model specific filters together with typeDefOid filter to scope by model type
                    var modelFilters = this.getStoreFilter(model);
                    if (!Ext.isEmpty(modelFilters)) {
                        filter = _.reduce(Ext.Array.from(modelFilters), function (result, modelFilter) {
                            return result.and(modelFilter);
                        }, filter);
                    }

                    return filter;
                }, this);

                // OR model filters together so we get back all models we asked for
                return _.reduce(filters, function (result, filter) {
                    return Ext.isEmpty(result) ? filter : result.or(filter);
                }, null, this);
            }
        },

        _initStoreFilters: function() {
            var filters = this._mergeConfigFilters(this._getFiltersForModels());
            if (this.filterCollection) {
                this.filterCollection.addPermanentFilter(filters);
                filters = this.filterCollection.toArray();
            }

            this.store.setFilter(filters);
        },

        _getFiltersForModels: function() {
            return Ext.isEmpty(this.store.models) ? this.getStoreFilter(this.store.model) : this._getModelScopedFilters(this.store.models);
        },

        _mergeConfigFilters: function(filters) {
            filters = Ext.Array.from(filters);

            var configFilters = this.storeConfig.filters;

            if (!Ext.isEmpty(configFilters)) {
                filters = filters.concat(_.map(Ext.Array.from(configFilters), Ext.clone));
            }

            _.each(filters, function(f){
                if(f instanceof Rally.data.wsapi.Filter){
                    f.itemId = f.toString();
                } else if (Ext.isObject(f)){
                    f.itemId = Ext.create('Rally.data.wsapi.Filter', f).toString();
                }
            });

            return filters;
        },

        _queryForData: function() {
            return this.buildStore(this._getStoreConfig()).then({
                success: this._onStoreBuilt,
                scope: this
            });
        },

        _createAndAddCardsFromStore: function(store) {
            var records = [];
            store.each(function(record) {
                if (this.isMatchingRecord(record)) {
                    records.push(record);
                }
            }, this);

            this.createAndAddCards(records).then({
                success: function () {
                    this.fireEvent('load', this, records);
                    this._columnReady();
                },
                scope: this
            });
        },

        _onStoreBuilt: function(store) {
            this.store = store;

            this.store.on('load', this._onStoreLoad, this);

            if (store.getCount()) {
                // handle in-memory or pre-loaded stores
                this._createAndAddCardsFromStore(store);
            } else if (!this.storeConfig.hasOwnProperty('autoLoad') || this.storeConfig.autoLoad) {
                this.loadStore();
            }
        },

        _onStoreLoad: function(store, records, successful, options) {
            options = options || {};
            records = records || [];
            if (!this.rendered) {
                this.on('afterrender', Ext.bind(this._onStoreLoad, this, [store, records, successful, options]), {single: true});
                return;
            }

            var clearExistingCards = successful && store.clearOnPageLoad && !this._loadingMoreRecords;
            delete this._loadingMoreRecords;

            if (clearExistingCards) {
                this.clearCards();
            }

            if (records.length === 0) {
                this._hasStoppedLoadingRecords = true;
            }

            this.fireEvent('storeload', store, records, successful, options);

            if (successful) {
                records = _.filter(records, function(record) {
                    return this.isMatchingRecord(record) && (clearExistingCards || !this._isCardRendered(record));
                }, this);

                this.createAndAddCards(records).then({
                    success: function () {
                        if (this._shouldAutoLoadMoreRecords()) {
                            this.loadMoreRecords();
                        } else {
                            this.fireEvent('load', this, records);
                            this._columnReady();
                        }
                    },
                    failure: function () {
                        this._setLoading(false);
                    },
                    scope: this
                });

            } else {
                this._setLoading(false);
                this._onStoreLoadFailure();
            }
        },

        _isCardRendered: function(record) {
            return _.some(this.getCards(), function (card) {
                return card.record.getId() === record.getId();
            }, this);
        },

        _shouldAutoLoadMoreRecords: function() {
            if (this._hasMoreRecords() && this.isVisible()) {
                var cards = this.getCards();

                if (cards.length === 0) {
                    return true;
                }

                var thresholdCard = cards[cards.length - this.autoLoadCardThreshold] || cards[0];
                return thresholdCard.cardAboveBottomOfWindow();
            }

            return false;
        },

        getScrollElement: function () {
            return this.ownerCardboard && this.ownerCardboard.getScrollElement && this.ownerCardboard.getScrollElement();
        },

        isLoading: function () {
            return this._loading;
        },

        _setLoading: function (loading) {
            this._loading = loading;
        },

        /**
         * Load more records in a column. This assumes the store is a pageable store.
         */
        loadMoreRecords: function() {
            if (!this._hasMoreRecords()) {
                this._setLoading(false);
                return;
            }

            this._setLoading(true);
            this._loadingMoreRecords = true;

            this.store.nextPage({
                addRecords: true
            });
        },

        _onStoreLoadFailure: function() {
            Rally.ui.notify.Notifier.showError({
                message: 'There was a problem loading the data for column "' + this.value + '"'
            });

            this._columnReady();
        },

        _hasMoreRecords: function() {
            var totalCount = this.store.getTotalCount() || 0;
            return !this._hasStoppedLoadingRecords && totalCount > this.store.getCount();
        },

        _getBrowserTestCls: function() {
            return Rally.util.Test.toBrowserTestCssClass(this.getColumnHeader().getHeaderValue() || this.getValue());
        },

        _addBrowserTestCls: function() {
            _.invoke(this.getContentCells(), 'addCls', this._getBrowserTestCls());
            this.getColumnHeaderCell().addCls(this._getBrowserTestCls());
        },

        afterRender: function() {
            this.callParent(arguments);
            this.drawHeader();
            this._addBrowserTestCls();
        },

        _getInsertIndex: function(card) {
            var row = this.getRowFor(card),
                cards = this.getCardsInRow(row),
                records = _.invoke(cards, 'getRecord'),
                record = card.getRecord();
            records.push(record);
            this._sortRecords(records);
            return _.findIndex(records, function(r) {
                return record.getId() === r.getId();
            });
        },

        _sortRecords: function(records) {
            if (this.store.sorters.length) {
                records.sort(this.store.sorters.last().sort);
            }
        },

        _getStoreConfig: function() {
            var defaultPageSize = 15,
                sorters = !Ext.isEmpty(this.storeConfig.sorters) ?
                    this.storeConfig.sorters : [this._getDefaultSorter()];

            return {
                sorters: sorters,
                fetch: this.getAllFetchFields(),
                search: this.storeConfig.search,
                pageSize: this.storeConfig.pageSize || defaultPageSize,
                useShallowFetch: this.storeConfig.useShallowFetch
            };
        },

        _getDefaultSorter: function() {
            return {
                property: Rally.data.Ranker.RANK_FIELDS.MANUAL,
                direction: 'ASC'
            };
        },

        _getSortProperty: function() {
            if (this.store && this.store.sorters && this.store.sorters.getCount()) {
                return this.store.sorters.getAt(0).property;
            }

            return Rally.data.Ranker.RANK_FIELDS.MANUAL;
        },

        getColumnHeader: function() {
            return this.columnHeader;
        },

        getColumnHeaderCell: function() {
            return Ext.get(this.headerCell);
        },

        getHeaderTitle: function() {
            return this.getColumnHeader().down('#headerTitle');
        },

        onRowAdded: function(row) {
            this.fireEvent('rowadd', this, row);
            if(this.isHidden()) {
                this.hide();
                row.hideColumn(this);
            }
        },

        /**
         * Get the rows in this column
         * @returns {Rally.ui.cardboard.row.Row[]}
         */
        getRows: function() {
            return this.ownerCardboard.getRows();
        },

        /**
         * Get the row corresponding to the specified card
         * @param {Rally.ui.cardboard.Card} card
         * @returns {Rally.ui.cardboard.row.Row}
         */
        getRowFor: function(card) {
            return this.ownerCardboard.getRowFor(card);
        },

        getContentCells: function() {
            return _.invoke(this.getRows(), 'getContentCellFor', this);
        },

        getContentCellContainers: function() {
            return _.invoke(this.getContentCells(), 'parent');
        },

        drawHeader: function() {
            if (!this.getColumnHeader()) {

                var config = {
                    renderTo: this.getColumnHeaderCell()
                };

                config = Ext.merge({}, config, this.columnHeaderConfig);
                this.columnHeader = Ext.widget(config);
            }
        },

        /**
         * Remove all the cards from this column
         */
        clearCards: function() {
            this._cancelInProgressAsyncCardRendering();
            _.each(this.getCards(), function(card) {
                this.removeCard(card, true);
            }, this);
            this._cardsByRow = {};
        },

        _cancelInProgressAsyncCardRendering: function () {
            if (!_.isUndefined(this._processBatchOfCardsTimeoutId)) {
                clearTimeout(this._processBatchOfCardsTimeoutId);
                delete this._processBatchOfCardsTimeoutId;
            }
        },

        /**
         * Get all the cards in this column
         * @returns {Rally.ui.cardboard.Card[]} Returns all cards from this column.
         */
        getCards: function() {
            return _.reduce(this.getRows(), function(memo, row) {
                return memo.concat(this.getCardsInRow(row));
            }, [], this);
        },

        /**
         * Get all the cards in this column and the specified row
         * @param {Rally.ui.cardboard.row.Row} row
         * @returns {Rally.ui.cardboard.Card[]} Returns all cards from this column in the specified row
         */
        getCardsInRow: function(row) {
            var cardsInRow = this._cardsByRow[row.getRowValue()];
            return (cardsInRow && cardsInRow.getRange()) || [];
        },

        /**
         *
         * isMatchingRecords a record by its object id or its domNode or its ext element
         * @param {Rally.data.Model/String} searchCriteria An objectId, or record
         * @returns {Object} The returned object will be in this format. {index:9,record: {get:set:},card: {}}
         */
        findCardInfo: function(searchCriteria) {
            var foundCard = null;
            searchCriteria = searchCriteria.get ? searchCriteria.getId() : searchCriteria;

            _.forEach(this.getCards(), function(card) {
                if (card.getRecord().getId() === searchCriteria ||
                    card.getEl() === searchCriteria ||
                    card.getEl() === Ext.get(searchCriteria)) {
                    var row = this.getRowFor(card);
                    foundCard = {
                        record: card.getRecord(),
                        index: _.indexOf(this.getCardsInRow(row), card),
                        card: card,
                        row: row
                    };

                    return false;
                }
            }, this);

            return foundCard;
        },

        /**
         * Gets a card by its record
         * @param {Rally.data.Model} record A record that will be used to retrieve the matching card from this column.
         * @returns {Rally.ui.cardboard.Card} The requested card
         */
        getCard: function(record) {
            var result = this.findCardInfo(record);
            if (result) {
                return result.card;
            }
            return null;
        },


        /**
         * Gets records for this column
         * @param {String}type An optional param that can be used to restrict what Rally object type will be returned
         * @returns {Rally.data.Model[]} The records in this column that are contained in this column.
         */
        getRecords: function(type) {
            var records = [];
            Ext.each(this.getCards(), function(card) {
                var record = card.getRecord();
                if (Ext.isEmpty(type) || (record.get("_type") === type)) {
                    records.push(record);
                }
            });
            return records;
        },

        /**
         * Determines whether the specified record may be contained within this column
         * (If its value matches that of this column)
         *
         * @param {Rally.data.Model} record
         */
        isMatchingRecord: function(record) {
            var recordValue = record.get(this.attribute),
                field = record.getField(this.attribute),
                typePath = record.self.typePath,
                models = this.store.models || Ext.Array.from(this.store.model),
                supportedTypes = _.pluck(models, 'typePath');

            if (!field || !_.contains(supportedTypes, typePath)) {
                return false;
            }

            var columnValue = this.getValue();

            // Field values can be converted from null. So we need to convert the column
            // value in case it is null
            if (Ext.isFunction(field.convert)) {
                columnValue = field.convert(columnValue, record);
            }

            return (columnValue === recordValue ||
            (Rally.util.Ref.isRefUri(columnValue) &&
            Rally.util.Ref.getRelativeUri(recordValue) === Rally.util.Ref.getRelativeUri(columnValue)));
        },

        /**
         * Adds a card to this column.
         * @param {Rally.data.Model} record
         * @param {Number} index The zero based index where the card will be added.
         *  This parameter is deprecated, pass null to place the card in the correct position based on the current sort criteria.
         * @param {Boolean} highlight true to highlight card after it has been added.
         * @param {Object} cardConfig config to be used to create the card
         */
        createAndAddCard: function(record, index /* deprecated, pass null to auto place the card */, highlight, cardConfig) {
            var card;
            if (this.isMatchingRecord(record)) {
                this.recordProcessor.process([record]);
                card = this._createCard(record, cardConfig);
                this.addCard(card, index, highlight);
            }

            return card;
        },

        _createCard: function(record, cardConfig) {
            if (this.fields && this.fields.length > 0) {
                if (!Ext.isObject(cardConfig)) {
                    cardConfig = {};
                }
                cardConfig.fields = Ext.Array.union(this.cardConfig.fields || [], this.fields || []);
            }

            var config = Ext.merge({}, this.cardConfig, {
                record: record
            }, cardConfig);

            var card = Ext.widget(config.xtype, config);

            card.rankRecordHelper = {
                _addColumnFilters: function(storeConfig) {
                    var row = card.ownerColumn.getRowFor(card);
                    storeConfig.filters = Ext.Array.merge(
                        storeConfig.filters || [],
                        card.ownerColumn.store.filters.getRange());
                    if(card.ownerColumn.getRows().length > 1) {
                        storeConfig.filters.push({
                            property: row.fieldDef.name,
                            operator: '=',
                            value: row.getRowValue()
                        });
                    }
                },

                findRecordToRankAgainst: function(options) {
                    options = options || {};
                    var extremeLoadOptions = {
                        last: !options.highest,
                        metricsCmp: options.requester,
                        storeConfig: {}
                    };
                    this.rankRecordHelper._addColumnFilters(extremeLoadOptions.storeConfig);
                    return Rally.data.Ranker.loadExtremeRankedRecord(this.ownerColumn.store, extremeLoadOptions)
                        .then(function(record) {
                            Ext.callback(options.success, options.scope, [record]);
                            return record;
                        });
                },

                getMoveToPositionStore: function(options) {
                    options = options || {};

                    var store = this.ownerColumn.store;

                    Ext.merge(options, {
                        storeConfig: {
                            model: store.model,
                            context: store.context
                        }
                    });

                    this.rankRecordHelper._addColumnFilters(options.storeConfig);

                    return Deft.Promise.when(Ext.create(store.self, options.storeConfig));
                },

                scope: card
            };

            return card;
        },

        /**
         * @protected
         * Adds a card to this column.
         * @param {Rally.ui.cardboard.Card} card
         * @param {Number} index The zero based index where the card will be added.
         *  This parameter is deprecated, pass null to place the card in the correct position based on the current sort criteria.
         * @param {Boolean} highlight true to highlight card after it has been added.
         */
        addCard: function(card, index /* deprecated, pass null to auto place the card */, highlight) {
            var record = card.getRecord();
            this.assign(record);

            this._renderCard(card, index);

            if (highlight) {
                card.highlight();
            }

            this.fireEvent('addcard');
            card.fireEvent('ready', card);
            return card;
        },

        _getContentContainerForCard: function(card) {
            var row = this.getRowFor(card);
            return row.getContentCellFor(this);
        },

        _renderCard: function(card, index) {
            this.fireEvent('beforecardrender', card, this);

            if (card.rendered) {
                if (card.ownerColumn) {
                    card.ownerColumn.removeCard(card, false);
                }

                index = this._insertCardAtIndex(card, index);
                this._setCardOwnerColumn(card);
            } else {
                if (!Ext.isNumber(index)) {
                    index = this._getInsertIndex(card);
                }

                this._setCardOwnerColumn(card);
                card.render(this._getContentContainerForCard(card), index);
            }

            this._addCardToCollection(card, index);
            this._relayCardEvents(card);
            this.fireEvent('cardready', card, this);
        },

        _insertCardAtIndex: function(card, index) {
            var row = this.getRowFor(card),
                cards = this.getCardsInRow(row),
                cardEl = card.getEl(),
                containerEl = row.getContentCellFor(this);

            index = Ext.isNumber(index) ? index : (this._getInsertIndex(card) || 0);

            if (cards.length === 0) {
                containerEl.insertFirst(cardEl);
            } else if (index >= cards.length) {
                cardEl.appendTo(containerEl);
            } else {
                this._insertCardBeforeOther(card, cards[index]);
            }

            return index;
        },

        _insertCardBeforeOther: function(card, otherCard) {
            if (otherCard !== card) { // sometimes we try to render a card to a position where it already exists
                card.getEl().insertBefore(otherCard.getEl());
            }
        },

        _setCardOwnerColumn: function(card) {
            card.ownerColumn = this;
            card.on('destroy', function() {
                card.ownerColumn = null;
            }, this, {single: true});
        },

        _relayCardEvents: function(card) {
            if (card._columnRelays) {
                card._columnRelays.destroy();
            }
            card._columnRelays = this.relayEvents(card, ['select', 'deselect', 'datachanged', 'cardcopied']);
        },

        _addCardToCollection: function(card, index) {
            var key = this._getCardKey(card),
                row = this.getRowFor(card),
                cards = this._cardsByRow[row.getRowValue()];
            if(!cards) {
                cards = Ext.create('Ext.util.MixedCollection');
                this._cardsByRow[row.getRowValue()] = cards;
            }
            if (Ext.isNumber(index)) {
                cards.insert(index, key, card);
            } else {
                cards.add(key, card);
            }
            this.mon(card, 'destroy', function() {
                this._removeCardFromCollection(card);
            }, this, {single: true});
        },

        _removeCardFromCollection: function(card) {
            _.each(this._cardsByRow, function(cards) {
                return !cards.removeAtKey(this._getCardKey(card));
            }, this);
        },

        _getCardKey: function(card) {
            var key = card.record.getId();
            if (!key) {
                Ext.Error.raise('card.record.id not found');
            }
            return key;
        },

        /**
         * @protected
         * Assign a record to this column by setting the appropriate value on it
         * @param record
         */
        assign: function(record) {
            record.set(this.attribute, this.getValue());
        },

        /**
         * Removes a card from this column.
         * @param {Rally.ui.cardboard.Card/Rally.data.wsapi.Model/Object} card The card or record to be used to find this card.
         * Could also be an object which has a "card" property.
         */
        removeCard: function(card, destroy) {
            var foundCardInfo = card.card || this.findCardInfo(card.record || card);

            if (foundCardInfo) {
                if (destroy !== false) {
                    foundCardInfo.card.destroy();
                } else {
                    foundCardInfo.card.getEl().parent().dom.removeChild(foundCardInfo.card.getEl().dom);
                }
                this._removeCardFromCollection(foundCardInfo.card);
            }
            this.fireEvent('removecard');
            card.ownerColumn = null;
        },

        /**
         * Refreshes a card with an updated record.
         * @param {Rally.data.Model} record The record containing new data to update the card with.
         * @param {Object} [options]
         * @param {Boolean} [options.rerank=false] Pass true to indicate that the card has been reranked
         * @param {Function} options.callback Function to be called once the card is refreshed.
         * Will only be called if card is still valid for this board.
         * @param {Object} options.scope The scope (this reference) in which the callback function is executed.
         */
        refreshCard: function(record, options) {
            var deferred = new Deft.Deferred(),
                foundCard = record.card ? record : this.findCardInfo(record);

            options = options || {};

            if (foundCard) {
                // Yo dawg I heard you like ifs, so I put some ifs in your ifs
                var card = foundCard.card;

                return this.refreshRecord(record, function(records) {

                    if (records.length === 0) {
                        this.fireEvent('cardinvalid', this, card);
                    } else if (records.length === 1) {
                        var refreshedRecord = records[0];
                        card.setRecord(refreshedRecord);
                        this._rerenderCard(card);
                        if (options.rerank || !this._cardIsInCorrectRow(card)) {
                            this.addCard(card, null, true);
                        }

                        if(Rally.realtime.Realtime.isRealtimeMessage(record)
                            && _.contains(record.data._changedFields, this.ownerCardboard.attribute)
                            && record.data[this.valueField] !== this.value) {
                            this.ownerCardboard.refreshCard(record);
                        } else {
                            Ext.callback(options.callback, options.scope, [card]);
                            this.fireEvent('cardupdated', foundCard.card);
                        }
                        deferred.resolve(card);
                    }
                }, this);
            } else {
                deferred.resolve();
            }

            return deferred.promise;
        },

        /**
         * @private
         * Refresh all the other tasks in the same row/col
         * intersection as the specified record.  This is necessary for apps
         * like task board when reranking since the TaskIndex of all the other cards was
         * also just updated on the server and we need to know the new values to get the
         * cards to display in the correct place.
         * @param record the record which was originally re-ranked
         */
        refreshNeighboringTaskIndices: function(record) {
            var row = this.getRowFor(record),
                cards = this.getCardsInRow(row),
                store = this.store,
                refreshStoreConfig = {
                    model: store.model,
                    context: store.context,
                    filters: store.filters.getRange(),
                    sorters: store.sorters.getRange(),
                    limit: cards.length,
                    fetch: ['TaskIndex']
                };
            if(!row.isDefault) {
                refreshStoreConfig.filters.push({
                    property: row.fieldDef.name,
                    value: row.getRowValue()
                });
            }
            var refreshStore = Ext.create(store.self, refreshStoreConfig);
            return refreshStore.load().then({
                success: function () {
                    _.each(cards, function (card) {
                        var refreshedRecord = refreshStore.getById(card.getRecord().getId());
                        if(refreshedRecord.getId() !== record.getId()) {
                            card.getRecord().set('TaskIndex', refreshedRecord.get('TaskIndex'));
                            this.addCard(card, null, false);
                        }
                    }, this);
                },
                scope: this
            });
        },

        _cardIsInCorrectRow: function(card) {
            return card.getEl().parent().dom === this._getContentContainerForCard(card).dom;
        },

        /**
         * Refreshes the record so that it populates all the fields such that it can be used in this column.
         * @param {Rally.data.wsapi.Model} record The record to be refreshed
         * @param {Function} callback Called once the record is loaded.  @deprecated - use returned promise instead
         * @param {Rally.data.wsapi.Model[]} callback.records records returned by the load
         * @return {Deft.Promise(Rally.data.wsapi.Model} record returned by the load
         */
        refreshRecord: function(record, callback) {
            var deferred = Ext.create('Deft.promise.Deferred');
            var promise = deferred.promise;
            this.recordLoadBegin({ description: 'refreshing record' });
            this.store.reloadRecord(record, {
                requester: this,
                fetch: this.getAllFetchFields(),
                useShallowFetch: this.storeConfig.useShallowFetch
            }).then({
                success: function(refreshedRecord) {
                    refreshedRecord.join(this.store);
                    Ext.callback(callback, this, [[refreshedRecord]]);
                    deferred.resolve(refreshedRecord);
                },
                failure: function(operation) {
                    Ext.callback(callback, this, [[]]);
                    deferred.reject(operation);
                },
                scope: this
            });

            promise.always(function() {
                this.recordLoadEnd();
            }, this);

            return promise;
        },

        /**
         * Creates a card for each record passed in
         * @param {Rally.data.Model[]} records
         */
        createAndAddCards: function(records) {
            var deferred = new Deft.Deferred();

            if (this.recordProcessor) {
                this.recordProcessor.process(records);
            }

            if (this.isDestroyed) {
                deferred.resolve();
            } else {
                this._processBatchOfCards(records, 0, 1, function() {
                    deferred.resolve();
                }, this);
            }

            return deferred.promise;
        },

        _rerenderCard: function(card) {
            this.recordProcessor.process([card.getRecord()]).then(function(renderedRecords) {
                card.reRender();
            });
        },

        _processBatchOfCards: function(records, start, quantity, callback, scope) {
            Ext.suspendLayouts();

            var end = start + quantity;
            var cards = [];
            _.each(records.slice(start, end), function(record) {
                var card = this._createCard(record);
                this._renderCard(card);

                cards.push(card);
            }, this);

            Ext.resumeLayouts(true);

            _.each(cards, function(card) {
                card.fireEvent('ready', card);
            });

            if (end < records.length) {
                var delayInMilliseconds = 1;
                this._processBatchOfCardsTimeoutId = Ext.defer(this._processBatchOfCards, delayInMilliseconds, this, [records, end, quantity, callback, scope]);
            } else {
                delete this._processBatchOfCardsTimeoutId;
                Ext.callback(callback, scope);
            }
        },

        _columnReady: function() {
            if (!this.rendered) {
                this.on('afterrender', this._columnReady, this);
                return;
            }

            this._setLoading(false);
            this.fireEvent('ready', this);
        },

        onDestroy: function() {
            this.clearCards();

            if (this.store && this.store.un) {
                this.store.un('load', this._onStoreLoad, this);
            }

            var header = this.getColumnHeader();
            if (header) {
                header.destroy();
            }

            this.callParent(arguments);
        },

        getMinWidth: function () {
            return 170;
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * A wrapper component that displays a grid and/or a board.
     * This component is enhanced via plugins to add functionality like add new, field/column selection, filtering and toggling between grid and board views.
     *
     *     Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
     *           models: ['userstory'],
     *           autoLoad: true,
     *           enableHierarchy: true
     *       }).then({
     *           success: function(store) {
     *               Ext.create('Ext.Container', {
     *                   items: [{
     *                       xtype: 'rallygridboard',
     *                       context: this.getContext(),
     *                       modelNames: ['userstory'],
     *                       toggleState: 'grid',
     *                       plugins: [
     *                           'rallygridboardtoggleable'
     *                       ],
     *                       cardBoardConfig: {
     *                           attribute: 'ScheduleState'
     *                       },
     *                       gridConfig: {
     *                           store: store,
     *                           columnCfgs: [
     *                               'Name',
     *                               'ScheduleState',
     *                               'Owner',
     *                               'PlanEstimate'
     *                           ]
     *                       },
     *                       height: this.getHeight()
     *                   }]
     *               });
     *           }
     *       });
     *
     * More examples of using this component and its plugins may be found in the [Examples](#!/example) section.
     */
    Ext.define('Rally.ui.gridboard.GridBoard', {
        extend: 'Ext.Container',
        mixins: ['Rally.app.Scopeable'],
        requires: [
            'Rally.ui.LeftRight',
            'Rally.ui.gridboard.GridBoardToggle',
            'Rally.ui.cardboard.CardBoard',
            'Rally.ui.grid.TreeGrid',
            'Rally.ui.gridboard.plugin.GridBoardCustomView',
            'Rally.data.filter.FilterCollection'
        ],

        alias: 'widget.rallygridboard',
        cls: 'rui-gridboard',

        /**
         * @cfg {Object}
         * Config passed into cardboard.
         */
        cardBoardConfig: {},

        /**
         * @cfg {Object}
         * Config passed into grid.
         */
        gridConfig: {},

        /**
         * @cfg {Object}
         * Common store configuration properties
         * to be applied to both the board and grid views
         */
        storeConfig: {},

        /**
         * @cfg {Array}
         * An array of model names of types to view on the grid board.
         */
        modelNames: [],

        /**
         * @cfg {String}
         * Used to configure plugins and child components that require a stateId
         */
        stateId: 'gridboard',

        /**
         * @inheritdoc
         * If the board is not meant to be toggled, state should be disabled to prevent the chance for gridboard
         * to load in an invalid state
         */
        stateful: true,

        /**
         * @cfg {String}
         * Which component to show- grid or board
         */
        toggleState: 'grid',

        /**
         * @inheritdoc
         */
        layout: {
            type: 'auto'
        },

        items: [
            {
                itemId: 'header',
                xtype: 'rallyleftright',
                padding: '4 10',
                overflowX: 'hidden'
            }
        ],

        /**
         * @deprecated
         *
         * Do not set this to true for new things
         */
        useFilterCollection: true,

        initComponent: function() {
            this.plugins = this.plugins || [];
            this.stateId = this.getAppContextOrEnvironmentContext().getScopedStateId(this.stateId);

            this.callParent(arguments);

            this.addEvents([
            /**
             * @event toggle
             * Fires when the toggle value is changed.
             * @param {String} toggleState 'grid' or 'board'.
             * @param {Ext.Component} gridOrBoard grid or board component.
             */
                'toggle',
            /**
             * @event load
             * Fires when the data store for the grid or board has loaded.
             * @param {Rally.ui.gridboard.GridBoard} this
             */
                'load',
            /**
             * @event recordcreate
             * Fires when a new record is created.
             * @param {Ext.data.Record} record The record that was created.
             */
                'recordcreate',
            /**
             * @event recordupdate
             * Fires when a record is updated.
             */
                'recordupdate',
            /**
             * @event preferencesaved
             * Fires after the preference has been saved
             * @param {Rally.data.wsapi.Model} record for preference
             */
                'preferencesaved',
            /**
             * @event modeltypeschange
             * Fires when the model types of the gridboard are changed.
             */
                'modeltypeschange'
            ]);

            this.on('modeltypeschange', function (gridboard, types) {
                this.modelNames = types;
            }, this);
        },

        /**
         * Delay the addition of the grid or board until plugins had a chance to modify some state
         * and the header has rendered in order to set the height of the tree grid.
         * Plugins can modify things like what fields are displayed
         * @private
         */
        afterRender: function() {
            this.callParent(arguments);
            this._addGridOrBoard(this.getToggleState());
        },

        applyState: function (state) {
            this.toggleState = state.toggleState;
        },

        getState: function () {
            return {
                toggleState: this.getToggleState()
            };
        },

        destroy: function() {
            var grid = null;

            if (this.getToggleState() === 'grid') {
                grid = this.getGridOrBoard();
                if (grid && grid.store && _.isFunction(grid.store.clearData)) {
                    //clean up records in the store to free up memory
                    grid.store.clearData();
                }
            }

            this.callParent(arguments);
        },

        setToggleState: function (toggleState) {
            if (this.toggleState !== toggleState) {
                this.toggleState = toggleState;
                this.saveState();
                if (this.down('#gridOrBoard')) {
                    this.remove('gridOrBoard', true);
                }
                this._addGridOrBoard(toggleState);
            }
        },

        getToggleState: function () {
            return this.toggleState;
        },

        /**
         * Get the header
         * @return {Rally.ui.LeftRight}
         */
        getHeader: function() {
            return this.down('#header');
        },

        /**
         * Get the currently shown grid or board component
         * @return {Rally.ui.cardboard.CardBoard|Rally.ui.grid.Grid}
         */
        getGridOrBoard: function() {
            return this.down('#gridOrBoard');
        },

        /**
         * Get the names of the artifacts currently shown
         * @returns {String[]}
         */
        getModelNames: function() {
            return this.modelNames;
        },

        /**
         * Get the models of the artifacts currently shown
         * @returns {Rally.data.Model[]}
         */
        getModels: function() {
            return this.getGridOrBoard().getModels();
        },

        applyCustomFilter: function(filterObj) {
            var gridOrBoard = this.getGridOrBoard();

            this.currentCustomFilter = filterObj;

            if (gridOrBoard) {
                if (this.getToggleState() === 'board') {
                    this._applyBoardFilters(gridOrBoard, filterObj);
                } else {
                    this._applyGridFilters(gridOrBoard, filterObj);
                }
            }
        },

        /**
         * Configure filters. Filters can be {Ext.util.Filter} instances or filter config objects.
         *
         * @deprecated DO NOT USE THIS!  THIS WILL BE DELETED, THIS IS NOT THE RIGHT WAY TO FILTER ANY MORE
         *             Please use applyCustomFilter (above) instead
         *
         * @param {Ext.util.Filter|Ext.util.Filter[]|Object|Object[]} filter
         * @param {String[]} clearFilterKeys
         */
        setFilter: function(filter, clearFilterKeys) {
            var gridOrBoard = this.getGridOrBoard();

            if (gridOrBoard) {
                gridOrBoard.filter(filter, clearFilterKeys);
            }
        },

        /**
         * Returns the currently applied filter.
         *
         * @returns {Ext.util.Filter|Ext.util.Filter[]|Object|Object[]}
         */
        getFilter: function() {
            return this.currentFilter;
        },

        setHeight: function() {
            this.callParent(arguments);
            var gridOrBoard = this.getGridOrBoard();
            if(gridOrBoard && gridOrBoard.rendered && gridOrBoard.getHeight() !== this.getAvailableGridBoardHeight()) {
                this.getGridOrBoard().setHeight(this.getAvailableGridBoardHeight());
            }
        },

        _addGridOrBoard: function(toggleState) {
            var gridOrBoard = null;

            if (toggleState === 'board') {
                gridOrBoard = this._addBoard();
            } else if (toggleState === 'grid') {
                gridOrBoard = this._addGrid();
            }

            this.fireEvent('toggle', toggleState, gridOrBoard, this);
        },

        _addBoard: function() {
            var board = this.add(this._getBoardConfig());
            this.mon(board, 'load', this._onGridOrBoardLoad, this);
            this.mon(board, 'cardupdated', this._onCardUpdated, this);
            this.mon(board, 'cardcopied', this._onCardCopied, this);
            return board;
        },

        /**
         * @private
         */
        getAvailableGridBoardHeight: function() {
            return this.getHeight() - this.down('#header').getHeight() - 10;
        },

        _getBoardConfig: function() {
            var config = Ext.merge({
                itemId: 'gridOrBoard',
                xtype: 'rallycardboard',
                types: this.modelNames,
                attribute: 'ScheduleState',
                storeConfig: {},
                context: this.getContext(),
                cls: 'cardboard',
                cardConfig: {
                    componentCls: 'iterationtrackingboard-card',
                    editable: true,
                    showColorIcon: true
                },
                height: this.getAvailableGridBoardHeight()
            }, this.cardBoardConfig);

            this._setBoardConfigFilters(config);

            return config;
        },

        _setBoardConfigFilters: function(config){
            _.merge(config, {storeConfig: this.storeConfig});

            if(this.useFilterCollection) {
                config.filterCollection = this._getFilterCollection(config.storeConfig && config.storeConfig.filters);
            } else {
                var filters = [].concat(config.storeConfig.filters || []);
                if(this.currentCustomFilter) {
                    filters = filters.concat(this.currentCustomFilter.filters || []);
                }
                config.storeConfig.filters = filters;
                if (this.currentCustomFilter && this.currentCustomFilter.types) {
                    config.types = this.currentCustomFilter.types;
                }
            }
        },

        _getGridConfig: function() {
            var context = this.getContext() || Rally.environment.getContext(),
                config =  Ext.merge({
                    itemId: 'gridOrBoard',
                    xtype: 'rallytreegrid',
                    context: context,
                    enableRanking: context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled,
                    defaultSortToRank: true,
                    enableBlockedReasonPopover: true,
                    stateId: this.stateId + '-grid',
                    stateful: true,
                    height: this.getAvailableGridBoardHeight()
                }, this.gridConfig);

            if (_.isEmpty(config.store)) {
                Ext.Error.raise('No grid store configured');
            }

            if (this.useFilterCollection) {
                config.filterCollection = this._getFilterCollection(this._getConfiguredFilters());
            }

            return config;
        },

        _getConfiguredFilters: function(extraFilters, types) {
            var isBoard = this.getToggleState() === 'board',
                filters =  _.compact(Ext.Array.merge(
                    this.storeConfig && this.storeConfig.filters,
                    isBoard && this.cardBoardConfig.storeConfig && this.cardBoardConfig.storeConfig.filters,
                    !isBoard && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
                    extraFilters));

            // don't do this if not artifact model or we are using filter collection
            if (!this.useFilterCollection && _.isFunction(this.getModels()[0].getArtifactComponentModel)) {
                filters = Rally.util.Filter.removeNonapplicableTypeSpecificFilters(filters, types, this.getModels()[0]);
            }

            return filters;
        },

        _addGrid: function() {
            var grid = this.add(this._getGridConfig());
            this.mon(grid, 'afterproxyload', this._onGridOrBoardLoad, this);
            if (!this.useFilterCollection && this.currentCustomFilter) {
                this._applyGridFilters(grid, this.currentCustomFilter);
            }
            return grid;
        },

        _applyGridFilters: function(grid, filterObj) {
            if (!_.isEmpty(filterObj.types)) {
                grid.store.parentTypes = filterObj.types;
            }
            grid.store.clearFilter(true);
            grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
        },

        _applyBoardFilters: function(board, filterObj) {
            board.refresh({
                types: filterObj.types,
                storeConfig: {filters: this._getConfiguredFilters(filterObj.filters || [], filterObj.types || [])}
            });
        },

        _onGridOrBoardLoad: function() {
            this.fireEvent('load', this);

            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _onCardCopied: function(cmp, record) {
            this.fireEvent('recordcreate', record);
        },

        _onCardUpdated: function(card) {
            this.fireEvent('recordupdate', card.getRecord());
        },

        /**
         * @deprecated
         *
         * @private
         * Create a new filter collection
         *
         * @param {Ext.util.Filter[]} filters Permanent filters to be added to filter collection on creation
         */
        _getFilterCollection: function(filters) {
            var filterCollection = Ext.create('Rally.data.filter.FilterCollection');

            if (filters) {
                filterCollection.addPermanentFilter(filters);
            }

            return filterCollection;
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     */
    Ext.define('Rally.ui.gridboard.planning.TimeboxColumn', {
        extend: 'Rally.ui.cardboard.Column',
        alias: 'widget.rallytimeboxcolumn',

        config: {
            /**
             * @cfg {String}
             * The name of the field inside the record that stores the start date
             */
            startDateField: 'StartDate',

            /**
             * @cfg {String}
             * The name of the field inside the record that stores the end date
             */
            endDateField: 'EndDate',

            /**
             * @cfg {Rally.data.wsapi.Model[]}
             * The timebox records (Iteration or Release) for this column
             */
            timeboxRecords: [],

            /**
             * @cfg {Object} columnStatusConfig
             * A config object that will be applied to the column's status area (between the header and content cells).
             * Used here for the progress bar.
             */
            columnStatusConfig: {
                xtype: 'rallytimeboxcolumnprogressbar',
                pointField: 'PlanEstimate',
                pointTotal: null
            }
        },

        cls: 'column',

        currentTimeboxCls: 'current-timebox',

        requires: [
            'Ext.XTemplate',
            'Rally.ui.gridboard.planning.TimeboxColumnProgressBar'
        ],

        constructor: function(config) {
            this.mergeConfig(config);
            this.config = Ext.merge({
                columnHeaderConfig: {
                    record: this._getTimeboxRecord(),
                    fieldToDisplay: 'Name',
                    editable: false
                }
            }, this.config);
            this.config.value = Rally.util.Ref.getRelativeUri(this._getTimeboxRecord());
            this.callParent([this.config]);
        },

        initComponent: function() {
            this.additionalFetchFields = _(this.additionalFetchFields || []).concat(
                _.first(this.columnStatusConfig.pointField.split('.'))
            ).unique().value();

            this.callParent(arguments);

            this.on({
                beforecarddroppedsave:  this._onBeforeCardDrop,
                addcard:                this._updateColumnStatus,
                load:                   this._updateColumnStatus,
                removecard:             this._updateColumnStatus,
                cardupdated:            this._updateColumnStatus,
                afterrender: {
                    fn: this._addPlanningClasses,
                    single: true
                },
                scope: this
            });

            this._loadUnfilteredStore();

        },
        _loadUnfilteredStore: function(){
            var filter = this.getStoreFilter(),
                pointField = this.columnStatusConfig.pointField,
                context = this.context.getDataContext();

            var store =  Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['HierarchicalRequirement','Defect'],
                filters: filter,
                context: context,
                fetch: [pointField]
            });
            store.load({
                callback: function(records, operation){
                    console.log('_loadUnfilteredStore callback', operation, records);
                    if (operation.wasSuccessful()){
                        var totalPoints = 0;

                        _.each(records, function(r){
                            totalPoints += r.get(pointField) || 0;
                        });
                    } else {
                        totalPoints = -1;
                        Rally.ui.notify.Notifier.showError({message: "Error fetching capacity total for unfiltered values."});
                    }
                    this.columnStatusConfig.pointTotal = totalPoints;
                    this._updateColumnStatus();
                },
                scope: this
            });


        },
        _updateColumnStatus: function() {
            if(this.columnStatus) {
                this.columnStatus.pointTotal = this.columnStatusConfig.pointTotal;  //Added to show total unfiltered points
                this.columnStatus.update();
            } else {
                this.drawStatus();
                this._updateColumnStatus();
            }
        },

        getStoreFilter: function(model) {
            return [
                {
                    property: this._getTimeboxModelName() + ".Name",
                    value: this._getTimeboxRecord().get('Name')
                },
                {
                    property: this._getTimeboxModelName() + "." + this.startDateField,
                    value: Rally.util.DateTime.toIsoString(this._getTimeboxRecord().get(this.startDateField))
                },
                {
                    property: this._getTimeboxModelName() + "." + this.endDateField,
                    value: Rally.util.DateTime.toIsoString(this._getTimeboxRecord().get(this.endDateField))
                }
            ];
        },

        getColumnStatus: function() {
            return this.columnStatus;
        },

        getStatusCell: function() {
            return Ext.get(this.statusCell);
        },

        isMatchingRecord: function(record) {
            return _.some(this.timeboxRecords, function(timeboxRecord) {
                return Rally.util.Ref.getOidFromRef(record.get(this._getTimeboxModelName())) === timeboxRecord.get('ObjectID');
            }, this);
        },

        afterRender: function() {
            this.callParent(arguments);
            this.drawStatus();
        },

        drawHeader: function() {
            this.callParent(arguments);
            this._addTimeboxDates();
        },

        drawStatus: function() {
            if (this.columnStatusConfig && !this.getColumnStatus()) {
                this.columnStatus = Ext.widget(Ext.merge({
                    renderTo: this.getStatusCell(),
                    column: this,
                    attribute: this.config.attribute
                }, this.columnStatusConfig));
            }
        },

        _addTimeboxDates: function() {
            this.getColumnHeader().add({
                xtype: 'component',
                html: this.getTimeboxDatesTpl().apply(this.getTimeboxDatesTplData())
            });
        },

        getTimeboxDatesTpl: function() {
            this.timeboxDatesTpl = this.timeboxDatesTpl || Ext.create('Ext.XTemplate',
                    '<div class="timeboxDates">{formattedStartDate} - {formattedEndDate}</div>');

            return this.timeboxDatesTpl;
        },

        getTimeboxDatesTplData: function() {
            return {
                formattedStartDate: this._getFormattedDate(this.startDateField),
                formattedEndDate: this._getFormattedDate(this.endDateField)
            };
        },

        getProgressBar: function() {
            return this.getColumnStatus();
        },

        _getFormattedDate: function(fieldName) {
            return Rally.util.DateTime.formatWithDefault(this._getTimeboxRecord().get(fieldName));
        },

        _getTimeboxRecord: function() {
            return this.timeboxRecords[0];
        },

        _getTimeboxModelName: function() {
            return this._getTimeboxRecord().self.displayName;
        },

        _onBeforeCardDrop: function(column, card) {
            var cardProjectRef = Rally.util.Ref.getRelativeUri(card.getRecord().get('Project'));
            if (cardProjectRef !== Rally.util.Ref.getRelativeUri(column.context.getProject())) {

                if (!Ext.Array.some(this.timeboxRecords, function(timeboxRecord) {
                        return cardProjectRef === Rally.util.Ref.getRelativeUri(timeboxRecord.get('Project'));
                    })) {
                    card.getRecord().set('Project', column.context.getProject()._ref);
                }
            }
        },

        _isCurrentTimebox: function(){
            var now = new Date();
            return this._getTimeboxRecord().get(this.startDateField) <= now && this._getTimeboxRecord().get(this.endDateField) >= now;
        },

        _addPlanningClasses: function() {
            var cls = 'planning-column';
            if (this._isCurrentTimebox()) {
                cls += ' ' + this.currentTimeboxCls;

            }
            _.invoke(this.getContentCellContainers(), 'addCls', cls);
            this.getStatusCell().addCls(cls);
            this.getColumnHeaderCell().addCls(cls);
        }
    });
})();
(function() {

    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     */
    Ext.define('Rally.ui.gridboard.planning.TimeboxColumnProgressBar', {
        extend: 'Ext.Component',
        alias: 'widget.rallytimeboxcolumnprogressbar',
        requires: [
            'Rally.ui.renderer.template.progressbar.TimeboxProgressBarTemplate',
            'Rally.data.util.PortfolioItemHelper',
            'Rally.ui.popover.PlannedVelocityPopover'
        ],

        /**
         * @cfg {String} (required)
         * The field on a card's record that represents the number of points for the card
         */
        pointField: undefined,
        pointTotal: undefined,

        constructor: function(config) {
            this.callParent(arguments);
            this.renderTpl = Ext.create('Rally.ui.renderer.template.progressbar.TimeboxProgressBarTemplate', {
                height: '18px',
                width: '80%',
                offsetWidth: '10%',
                progressBarComponent: this
            });
            this.attribute = config.attribute;
        },

        update: function() {
            var html = this.renderTpl.apply(this._getRenderData());
            this.callParent([html]);
            this._getProgressBarContainer().on('click', this._onPlannedVelocityLinkClick, this);
            this._getProgressBarContainer().on('mouseenter', this._onProgressBarMouseEnter, this);
            this._getProgressBarContainer().on('mouseleave', this._onProgressBarMouseLeave, this);
            this._createTooltip();
            this._hideEditIcon();
        },

        _onProgressBarMouseEnter: function() {
            this._showEditIcon();
        },

        _onProgressBarMouseLeave: function() {
            this._hideEditIcon();
        },

        _onPlannedVelocityLinkClick: function(event) {
            event.preventDefault();

            this._disableTooltip();
            this._createPopoverWithData();
        },

        _createPopoverWithData: function() {
            var saveTimeboxRecord = Ext.bind(this._saveTimeboxRecord, this),
                enableTooltip = Ext.bind(this._enableTooltip, this);

            Ext.create('Rally.ui.popover.PlannedVelocityPopover', {
                plannedVelocity: this._getParentPlannedVelocityRollup(),
                childVelocity: this._getChildrenPlannedVelocityRollup(),
                hasChildren: this._hasChildren(),
                projectName: this._getProjectName(),
                releaseName: this._getReleaseName(),
                target: this._getProgressBarContainer(),
                unitName: this._getUnitName(),
                onSaveClicked: function() {
                    var plannedVelocity = Ext.getCmp('plannedVelocityField').getValue();
                    saveTimeboxRecord(plannedVelocity);
                    this.close();
                },
                onCancelClicked: function() {
                    enableTooltip();
                    this.close();
                },
                listeners: {
                    hide: function() {
                        this._enableTooltip();
                    },
                    close: function() {
                        this._enableTooltip();
                    },
                    scope: this
                }
            });
        },

        _showEditIcon: function() {
            this.getEl().down('.icon-edit').show();
        },

        _hideEditIcon: function() {
            this.getEl().down('.icon-edit').hide();
        },

        _getProject: function() {
            return Rally.environment.getContext().getProject();
        },

        _getWorkspace: function() {
            return Rally.environment.getContext().getWorkspace();
        },

        _getProjectName: function() {
            return this._getProject().Name;
        },

        _getUnitName: function() {
            var key = this.attribute.toLowerCase();
            return this._getWorkspace().WorkspaceConfiguration[this._getUnitKey(key)];
        },

        _getReleaseName: function() {
            return this._getParentTimebox().get('Name');
        },

        _hasChildren: function() {
            return this._getChildTimeboxes().length;
        },

        _getUnitKey: function(key) {
            var keyMap = {
                iteration: 'IterationEstimateUnitName',
                release: 'ReleaseEstimateUnitName'
            };
            return keyMap[key];
        },

        _saveTimeboxRecord: function(plannedVelocity) {
            var timeboxRecord = this._getParentTimebox();

            timeboxRecord.set('PlannedVelocity', plannedVelocity);
            timeboxRecord.save();
            this.update();
        },

        _disableTooltip: function() {
            this.tooltip.disable();
        },

        _enableTooltip: function() {
            this.tooltip.enable();
        },

        _createTooltip: function() {
            if (this.tooltip) {
                this._destroyTooltip();
            }

            this.tooltip = Ext.create('Rally.ui.tooltip.ToolTip', {
                cls: 'set-planned-velocity-tooltip',
                bodyStyle: 'text-align: center;',
                width: 150,
                anchor: 'top',
                target: this._getProgressBarContainer(),
                html: 'Edit Planned Velocity'
            });
        },

        _destroyTooltip: function() {
            this.tooltip.destroy();
            delete this.tooltip;
        },

        _getProgressBarContainer: function() {
            return this.getEl().down('.progress-bar-container');
        },

        _getColumn: function() {
            return this.column;
        },

        _getRenderData: function() {
            var totalPointCount = this.pointTotal || this._getTotalPointCount();
            var totalPlannedVelocity = this._getTotalPlannedVelocityRollup();
            var parentPlannedVelocity = this._getParentPlannedVelocityRollup();
            var childPlannedVelocity = this._getChildrenPlannedVelocityRollup();

            return {
                percentDone: totalPlannedVelocity ? totalPointCount / totalPlannedVelocity : 0,
                amountComplete:  totalPointCount,
                total: totalPlannedVelocity,
                parentVelocity: parentPlannedVelocity,
                childVelocity: childPlannedVelocity
            };
        },

        _getTotalPointCount: function() {
            console.log('_getTotalPointcount', this._getColumn().getCards());
            return _.reduce(this._getColumn().getCards(), function(memo, card) {
                var points = this._getRecordValue(card.getRecord(), this.pointField);
                return Ext.isNumber(points) ? memo + points : memo;
            }, 0, this);
        },

        _getRecordValue: function (record, fieldName) {
            return _.isString(fieldName) && _.reduce(fieldName.split('.'), function (result, fieldName) {
                    if (result) {
                        return result.isModel ? result.get(fieldName) : result[fieldName];
                    }
                }, record);
        },

        _getParentTimebox: function() {
            var parent =  _.find(this._getTimeBoxRecords(), function(record) {
                return this._getProject()._refObjectUUID === record.get('Project')._refObjectUUID;
            }, this);
            return parent;
        },

        _getChildTimeboxes: function() {
            return _.filter(this._getTimeBoxRecords(), function(record) {
                return this._getProject()._refObjectUUID !== record.get('Project')._refObjectUUID;
            }, this);
        },

        _getTimeBoxRecords: function() {
            return this._getColumn().getTimeboxRecords();
        },

        _getRollup: function(collection, prop) {
            return _.reduce(collection, function(memo, record) {
                var plannedVelocity = record.get(prop);
                return Ext.isNumber(plannedVelocity) ? memo + plannedVelocity : memo;
            }, 0);
        },

        _getChildrenPlannedVelocityRollup: function() {
            return this._getRollup(this._getChildTimeboxes(), 'PlannedVelocity');
        },

        _getParentPlannedVelocityRollup: function() {
            var timeboxes = [];
            var parent = this._getParentTimebox();

            if(!parent) {
                return 0;
            }

            timeboxes.push(parent);

            return this._getRollup(timeboxes, 'PlannedVelocity');
        },

        _getTotalPlannedVelocityRollup: function() {
            return this._getRollup(this._getTimeBoxRecords(), 'PlannedVelocity');
        }

    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     */
    Ext.define('Rally.ui.gridboard.planning.TimeboxGridBoard', {
        extend: 'Rally.ui.gridboard.GridBoard',
        alias: 'widget.rallytimeboxgridboard',
        requires: [
            'Rally.util.Array',
            'Rally.data.ModelFactory',
            'Rally.ui.gridboard.TimeboxBlankSlate',
            'Rally.ui.gridboard.planning.BacklogColumn',
            'Rally.ui.gridboard.planning.TimeboxCardBoard',
            'Rally.ui.gridboard.planning.TimeboxColumn',
            'Rally.ui.gridboard.planning.TimeboxScrollable'
        ],
        mixins: ['Rally.Messageable'],

        cls: 'rui-gridboard planning-board',

        /**
         * @cfg {String}
         * The name of the field inside the record that stores the end date
         */
        endDateField: 'EndDate',

        /**
         * @cfg {Number}
         */
        numColumns: 3,

        /**
         * @cfg {String}
         * The name of the field inside the record that stores the start date
         */
        startDateField: 'StartDate',

        /**
         * @cfg {String} (required)
         * Either 'Iteration' or 'Release'
         */
        timeboxType: undefined,

        toggleState: 'board',

        initComponent: function() {
            this.on('toggle', function(toggleState, gridOrBoard) {
                if (toggleState === 'board' && !this._hasTimeboxes()) {
                    this.mon(gridOrBoard, 'aftercolumnrender', this._addBoardBlankSlate, this);
                }
            }, this);

            this.subscribe(this, Rally.Message.objectCreate, this._onObjectChange, this);
            this.subscribe(this, Rally.Message.objectUpdate, this._onObjectChange, this);
            this.subscribe(this, Rally.Message.objectDestroy, this._onObjectChange, this);

            this.callParent(arguments);
        },

        _addGridOrBoard: function() {
            if (!this.timeboxes) {
                Rally.data.ModelFactory.getModel({
                    type: this.timeboxType,
                    context: this.getContext().getDataContext(),
                    success: this._findTimeboxes,
                    scope: this
                });
                this.setLoading(true);
            } else {
                this.callParent(arguments);
            }
        },

        _getBoardConfig: function() {
            var initiallyVisibleTimeboxes = this._getInitiallyVisibleTimeboxes();
            var columns = this._getColumnConfigs(initiallyVisibleTimeboxes);
            return Ext.merge(this.callParent(arguments), {
                xtype: 'rallytimeboxcardboard',
                attribute: this.timeboxType,
                cardConfig: {
                    showBlockedReason: true,
                    showIconMenus: true
                },
                columns: columns,
                columnConfig: {
                    xtype: 'rallytimeboxcolumn',
                    endDateField: this.endDateField,
                    startDateField: this.startDateField,
                    storeConfig : {
                        fetch: ['Parent', 'Requirement'],
                        pageSize: Ext.isIE ? 25 : 100 // plan estimate rollups use client side data, so we need a lot of cards
                    }
                },
                plugins: [
                    {
                        ptype: 'rallytimeboxscrollablecardboard',
                        backwardsButtonConfig: {
                            elTooltip: 'Previous ' + this.timeboxType
                        },
                        columnRecordsProperty: 'timeboxRecords',
                        forwardsButtonConfig: {
                            elTooltip: 'Next ' + this.timeboxType
                        },
                        getFirstVisibleScrollableColumn: function(){
                            return this.getScrollableColumns()[0];
                        },
                        getLastVisibleScrollableColumn: function(){
                            return _.last(this.getScrollableColumns());
                        },
                        getScrollableColumns: function(){
                            return Ext.Array.slice(this.cmp.getColumns(), 1, this.cmp.getColumns().length);
                        }
                    }
                ],
                scrollableColumnRecords: this.timeboxes
            });
        },

        _getInitiallyVisibleTimeboxes: function(){
            if(this.timeboxes.length <= this.numColumns){
                return this.timeboxes;
            }

            var previousTimeboxes = [];
            var futureAndCurrentTimeboxes = [];
            Ext.Array.each(this.timeboxes, function (timeboxRecords) {
                if (timeboxRecords[0].get(this.endDateField) >= new Date()) {
                    futureAndCurrentTimeboxes.push(timeboxRecords);
                } else {
                    previousTimeboxes.push(timeboxRecords);
                }
            }, this);
            futureAndCurrentTimeboxes = Rally.util.Array.firstElementsOf(futureAndCurrentTimeboxes, this.numColumns);

            var possiblyVisibleTimeboxes = previousTimeboxes.concat(futureAndCurrentTimeboxes);
            return Rally.util.Array.lastElementsOf(possiblyVisibleTimeboxes, this.numColumns);
        },

        _getColumnConfigs: function(timeboxes) {
            var columns = [{
                xtype: 'rallyplanningbacklogcolumn',
                flex: this._hasTimeboxes() ? 1 : 1/3,
                columnHeaderConfig: {
                    headerTpl: 'Backlog'
                }
            }];

            Ext.Array.each(timeboxes, function(timeboxRecords) {
                columns.push({
                    columnHeaderConfig: {
                        record: timeboxRecords[0],
                        fieldToDisplay: 'Name',
                        editable: false
                    },
                    timeboxRecords: timeboxRecords
                });
            }, this);

            return columns;
        },

        _hasTimeboxes: function() {
            return this.timeboxes && this.timeboxes.length > 0;
        },

        _findTimeboxes: function(model) {
            Ext.create('Rally.data.wsapi.Store', {
                model: model,
                fetch: ['Name', this.startDateField, this.endDateField, 'Project', 'PlannedVelocity'],
                autoLoad: true,
                listeners: {
                    load: this._onTimeboxesLoad,
                    scope: this
                },
                context: this.getContext().getDataContext(),
                limit: Infinity
            });
        },

        _addBoardBlankSlate: function(board) {
            this.addCls('no-timebox');
            board.getEl().down('.columns tr td').setStyle('width', '33%');
            var blankSlateTd = Ext.DomHelper.append(board.getEl().down('.columns tr'), '<td class="blank-slate-column"></td>', true);

            var blankSlate = Ext.widget({
                xtype: 'rallytimeboxblankslate',
                timeboxType: this.timeboxType,
                context: this.getContext(),
                renderTo: blankSlateTd
            });

            this.on('destroy', function() {
                blankSlate.destroy();
            });

            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _onTimeboxesLoad: function(store) {
            var likeTimeboxesObj = {};
            store.each(function(timebox) {
                var timeboxKey = Ext.String.format("{0}{1}{2}", timebox.get('Name'), timebox.get(this.startDateField), timebox.get(this.endDateField));
                likeTimeboxesObj[timeboxKey] = Ext.Array.push(likeTimeboxesObj[timeboxKey] || [], timebox);
            }, this);

            var sortedLikeTimeboxes = _.sortBy(Ext.Object.getValues(likeTimeboxesObj), function(likeTimeboxes) {
                return likeTimeboxes[0].get(this.endDateField);
            }, this);

            this.timeboxes = Ext.Array.filter(sortedLikeTimeboxes, function(likeTimeboxes) {
                return Ext.Array.some(likeTimeboxes, function(timebox) {
                    return Rally.util.Ref.getRelativeUri(timebox.get('Project')) === Rally.util.Ref.getRelativeUri(this.getContext().getProject());
                }, this);
            }, this);

            this.setLoading(false);
            this._addGridOrBoard('board');
        },

        _onObjectChange: function(record) {
            if (Ext.isArray(record)) {
                Ext.Array.each(record, this._onObjectChange, this);
                return;
            }

            if (record.get('_type').toLowerCase() === this.timeboxType.toLowerCase()) {
                var gridOrBoard = this.getGridOrBoard();
                if (gridOrBoard) {
                    gridOrBoard.destroy();
                }

                this.timeboxes = null;
                this._addGridOrBoard();
            }
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * The Ext.XTemplate used to render the percent done of a timebox, like a iteration, release, or generic timeframe.
     */
    Ext.define('Rally.ui.renderer.template.progressbar.TimeboxProgressBarTemplate', {
        requires: [
            'Rally.util.Colors'
        ],
        extend: 'Rally.ui.renderer.template.progressbar.ProgressBarTemplate',

        config: {
            calculateColorFn: function(recordData) {
                if (recordData.percentDone < 0.8) {
                    return Rally.util.Colors.blue_med;
                } else if (recordData.percentDone <= 1) {
                    return Rally.util.Colors.lime;
                } else {
                    return Rally.util.Colors.red_med;
                }
            },
            generateAmountCompleteText: function(recordData) {
                return Ext.util.Format.round(recordData.amountComplete, 2);
            },
            generateChildrenTotalVelocityText: function(recordData) {
                return recordData.childVelocity ? '(' + Ext.util.Format.round(recordData.childVelocity, 2) + ')' : '';
            },
            generateTotalPlannedVelocityText: function(recordData) {
                // The progressbar links to "Set Planned Velocity" if there is no planned velocity for the current
                // project and iteration (the "parent"), so we check that even though the total is what gets displayed.
                return (recordData.parentVelocity && recordData.total) ? Ext.util.Format.round(recordData.total, 2) : '<a href="#">Set Planned Velocity</a>';
            },
            calculatePercent: function(recordData) {
                var percentDone = recordData[this.percentDoneName];
                var totalPlannedVelocity = recordData.total;

                if(_.isNaN(percentDone) || totalPlannedVelocity === 0) {
                    return '--';
                } else {
                    return Math.round(percentDone * 100);
                }
            },
            getOffsetDimensions: function() {
                return 'width:' + this.offsetWidth + ';display: inline-block; color: white; text-align: center; vertical-align: top; line-height: 18px;';
            }
        },

        template: [
            '<tpl if="this.shouldShowPercentDone(values)">',
            '<div style="{[this.getOffsetDimensions()]}"></div>',
            '<div class="progress-bar-container field-{[this.percentDoneName]} {[this.getClickableClass()]} {[this.getContainerClass(values)]}" style="cursor: pointer; {[this.getDimensionStyle()]}">',
            '<div class="rly-progress-bar" style="background-color: {[this.calculateColorFn(values)]}; width: {[this.calculateWidth(values)]}; "></div>',
            '<tpl if="this.showDangerNotificationFn(values)">',
            '<div class="progress-bar-danger-notification"></div>',
            '</tpl>',
            '<div class="progress-bar-label">',
            '{[this.generateAmountCompleteText(values)]}',
            ' of ',
            '{[this.generateTotalPlannedVelocityText(values)]}',
            ' {[this.generateChildrenTotalVelocityText(values)]} ',
            '<span class="icon-edit" style="position:relative; top: 1px;"></span>',
            '</div>',
            '</div>',
            '<div style="{[this.getOffsetDimensions()]}">',
            '<span class="progressbar-percentage">{[this.calculatePercent(values)]}%</span>',
            '</div>',
            '</tpl>'
        ],

        constructor: function(config) {
            config.template = this.template;
            this.initConfig(config);
            return this.callParent(arguments);
        },

        apply: function(values, parent) {
            var html = this.callParent(arguments);
            return html === '' ? html : '<div class="progress-bar-background">' + html + '</div>';
        }
    });
})();
            
               Rally.launchApp('iteration-planning-board-unfiltered-utilization', {
                   name: 'Iteration Planning Board (Unfiltered Utilization)'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.planning-board .header {
    padding: 5px 5px 5px 10px;
}

.planning-board .header .add-new {
    float: left;
}

.planning-board .show-label {
    float: right;
    margin-top: 3px;
}

.planning-board .type-checkbox {
    float: right;
    margin: 5px;
}

.planning-board .manage-iterations {
    float: right;
    margin: 3px 10px 0 0;
}

.planning-board .artifact-type-chooser {
    margin-top: 4px;
}

.planning-board .add-new label {
    padding-top: 0;
}

.planning-board .add-new .new {
    margin-left: 0;
}

.planning-column.backlog .search-button {
    background: transparent url('search-button.gif');
}
    </style>

</head>
<body></body>
</html>